/*
 * Copyright 2022 Liam Twigger. All rights reserved.
 * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
 */

#include "bgfx_compute.sh"

//instance data for all instances (pre culling)
BUFFER_RO(instanceDrawDataIn, vec4, 0);
// Output
BUFFER_WR(indirectBuffer, uvec4, 1);
BUFFER_RO(instanceBufferOut, vec4, 2);
#ifdef INDIRECT_COUNT
BUFFER_WR(indirectCountBuffer, int, 3);
#endif

uniform vec4 u_numToDraw;
uniform vec4 u_fmin;
uniform vec4 u_fmax;

// Use 64*1*1 local threads
NUM_THREADS(64, 1, 1)
void main()
{
    int tId = int(gl_GlobalInvocationID.x);
    int numDrawItems = int(u_numToDraw.x);
    float time = 0.0;

    // Work out the amount of work we're going to do here
    int maxToDraw = numDrawItems;

    int numToDrawPerThread = maxToDraw/64 + 1;

    int idxStart = tId*numToDrawPerThread;
    int idxMax = min(maxToDraw, (tId+1)*numToDrawPerThread);

    // Prepare draw mtx
    for (int k = idxStart; k < idxMax; k++) {

        vec4 a = instanceBufferOut[k*6+0];
        vec4 b = instanceBufferOut[k*6+1];
        vec4 c = instanceBufferOut[k*6+2];
        vec4 d = instanceBufferOut[k*6+3];
        mat4x4 modelMat = mat4x4(a, b, c, d);
        uint draw=1u;

        // recupere la bbox du ieme objet...
        vec3 pmin= (instanceBufferOut[k*6+4]).xyz;
        vec3 pmax= (instanceBufferOut[k*6+5]).xyz;

        vec3 bboxSize = pmax.xyz - pmin.xyz;
        vec3 boxCorners[] = {
            pmin.xyz,
            pmin.xyz + vec3(bboxSize.x, 0, 0),
            pmin.xyz + vec3(0, bboxSize.y, 0),
            pmin.xyz + vec3(0, 0, bboxSize.z),
            pmin.xyz + vec3(bboxSize.xy, 0),
            pmin.xyz + vec3(0, bboxSize.yz),
            pmin.xyz + vec3(bboxSize.x, 0, bboxSize.z),
            pmin.xyz + vec3(bboxSize.xyz)
        };
        vec4 VPCorners[8];
        for (int p=0;p<8;p++){
            VPCorners[p]= u_proj * u_view * modelMat * vec4(boxCorners[p], 1.0);
        }

        bool left = true;
        bool right =true;
        bool up =true;
        bool down =true;
        bool front =true;
        bool far =true;


        for (int p=0;p<8;p++){
            left = left && VPCorners[p].x < -VPCorners[p].w;
            right = right &&VPCorners[p].x > VPCorners[p].w;
            up = up&&VPCorners[p].y < -VPCorners[p].w;
            down =down&& VPCorners[p].y > VPCorners[p].w;
            front = front && VPCorners[p].z < -VPCorners[p].w;
            far = far && VPCorners[p].z > VPCorners[p].w;
        }

        bool isAllOutside = left || right || up || down || front || far;
        if (isAllOutside){
            draw=0u;
        }


        drawIndexedIndirect(
        // Target location params:
        indirectBuffer, // target buffer
        k, // index in buffer
        // Draw call params:
        instanceDrawDataIn[k].w, // number of indices for this draw call
        draw, // number of instances for this draw call. You can disable this draw call by setting to zero
        instanceDrawDataIn[k].z, // offset in the index buffer
        instanceDrawDataIn[k].x, // offset in the vertex buffer. Note that you can use this to "reindex" submeshses - all indicies in this draw will be decremented by this amount
        k// offset in the instance buffer. If you are drawing more than 1 instance per call see gpudrivenrendering for how to handle
        );

    }

    #ifdef INDIRECT_COUNT
    if (tId == 0)
    {
        // If BGFX_CAPS_DRAW_INDIRECT_COUNT is supported, you can limit the
        // number of draw calls dynamically without a CPU round trip
        indirectCountBuffer[0] = maxToDraw;
    }
    #endif
}