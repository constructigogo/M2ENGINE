/*
 * Copyright 2022 Liam Twigger. All rights reserved.
 * License: https://github.com/bkaradzic/bgfx/blob/master/LICENSE
 */

#include "bgfx_compute.sh"

//instance data for all instances (pre culling)
BUFFER_RO(instanceDrawDataIn, vec4, 0);
// Output
BUFFER_WR(indirectBuffer, uvec4, 1);
BUFFER_RO(instanceBufferOut, vec4, 2);
BUFFER_WR(indirectCountBuffer, int, 3);
BUFFER_RW(instancePredicateBuffer, bool, 4);
SAMPLER2D(s_texOcclusionDepth, 5);


uniform vec4 u_numToDraw;
uniform vec4 u_input_Z_RT_size;
uniform vec4 u_cullingConfig;
uniform vec4 u_fmin;
uniform vec4 u_fmax;

// Use 64*1*1 local threads
NUM_THREADS(32, 1, 1)
void main()
{
    int tId = int(gl_GlobalInvocationID.x);
    int numDrawItems = int(u_numToDraw.x);
    float time = 0.0;

    // Work out the amount of work we're going to do here
    int maxToDraw = numDrawItems;

    int numToDrawPerThread = maxToDraw/32 + 1;

    int idxStart = tId*numToDrawPerThread;
    int idxMax = min(maxToDraw, (tId+1)*numToDrawPerThread);

    // Prepare draw mtx
    for (int k = idxStart; k < idxMax; k++) {

        vec4 a = instanceBufferOut[k*6+0];
        vec4 b = instanceBufferOut[k*6+1];
        vec4 c = instanceBufferOut[k*6+2];
        vec4 d = instanceBufferOut[k*6+3];
        mat4x4 modelMat = mat4x4(a, b, c, d);
        instancePredicateBuffer[k]=true;

        // recupere la bbox du ieme objet...
        vec3 pmin= (instanceBufferOut[k*6+4]).xyz;
        vec3 pmax= (instanceBufferOut[k*6+5]).xyz;

        vec3 bboxSize = pmax.xyz - pmin.xyz;
        vec3 boxCorners[] = {
        pmin.xyz,
        pmin.xyz + vec3(bboxSize.x, 0, 0),
        pmin.xyz + vec3(0, bboxSize.y, 0),
        pmin.xyz + vec3(0, 0, bboxSize.z),
        pmin.xyz + vec3(bboxSize.xy, 0),
        pmin.xyz + vec3(0, bboxSize.yz),
        pmin.xyz + vec3(bboxSize.x, 0, bboxSize.z),
        pmin.xyz + vec3(bboxSize.xyz)
        };
        vec4 VPCorners[8];
        for (int p=0;p<8;p++){
            VPCorners[p]= u_viewProj * modelMat * vec4(boxCorners[p], 1.0);
        }

        bool left = true;
        bool right =true;
        bool up =true;
        bool down =true;
        bool front =true;
        bool far =true;


        for (int p=0;p<8;p++){
            left = left && VPCorners[p].x < -VPCorners[p].w;
            right = right &&VPCorners[p].x > VPCorners[p].w;
            up = up&&VPCorners[p].y < -VPCorners[p].w;
            down =down&& VPCorners[p].y > VPCorners[p].w;
            front = front && VPCorners[p].z < -VPCorners[p].w;
            far = far && VPCorners[p].z > VPCorners[p].w;
        }

        bool isAllOutside = left || right || up || down || front || far;
        if (isAllOutside){
            instancePredicateBuffer[k]=false;
        }

        if (instancePredicateBuffer[k]){
            uint draw = 0u;

            float minZ = 2.0;
            vec2 minXY = vec2(1.0, 1.0);
            vec2 maxXY = vec2(0.0, 0.0);


            for (int i = 0; i < 8; i++)
            {
                //transform World space aaBox to NDC
                //vec4 clipPos = mul(u_viewProj, vec4(VPCorners[i]));
                vec4 clipPos = VPCorners[i];

                #if BGFX_SHADER_LANGUAGE_GLSL
                clipPos.z = 0.5 * (clipPos.z + clipPos.w);
                #endif
                clipPos.z = max(clipPos.z, 0);

                clipPos.xyz = clipPos.xyz / clipPos.w;

                clipPos.xy = clamp(clipPos.xy, -1, 1);
                clipPos.xy = clipPos.xy * vec2(0.5, -0.5) + vec2(0.5, 0.5);

                minXY = min(clipPos.xy, minXY);
                maxXY = max(clipPos.xy, maxXY);

                minZ = (min(minZ, clipPos.z));
            }

            vec4 boxUVs = vec4(minXY, maxXY);


            // Calculate hi-Z buffer mip
            ivec2 size = ivec2((maxXY - minXY) * u_input_Z_RT_size.xy);
            float mip = ceil(log2(max(size.x, size.y)));

            mip = clamp(mip, 0, u_cullingConfig.z);

            // Texel footprint for the lower (finer-grained) level
            float level_lower = max(mip - 1, 0);
            vec2 scale = vec2_splat(exp2(-level_lower));
            vec2 a = floor(boxUVs.xy*scale);
            vec2 b = ceil(boxUVs.zw*scale);
            vec2 dims = b - a;

            // Use the lower level if we only touch <= 2 texels in both dimensions
            if (dims.x <= 2 && dims.y <= 2){
                mip = level_lower;
            }
            #if BGFX_SHADER_LANGUAGE_GLSL
            boxUVs.y = 1.0 - boxUVs.y;
            boxUVs.w = 1.0 - boxUVs.w;
            #endif

            //load depths from high z buffer
            vec4 depth =
            {
            texture2DLod(s_texOcclusionDepth, boxUVs.xy, mip).x,
            texture2DLod(s_texOcclusionDepth, boxUVs.zy, mip).x,
            texture2DLod(s_texOcclusionDepth, boxUVs.xw, mip).x,
            texture2DLod(s_texOcclusionDepth, boxUVs.zw, mip).x,
            };

            //find the max depth
            float maxDepth = max(max(depth.x, depth.y), max(depth.z, depth.w));

            if (minZ <= maxDepth)
            {
                draw = 1u;
            } else {
                instancePredicateBuffer[k] = false;
            }

            drawIndexedIndirect(
            // Target location params:
            indirectBuffer, // target buffer
            k, // index in buffer
            // Draw call params:
            instanceDrawDataIn[k].w, // number of indices for this draw call
            draw, // number of instances for this draw call. You can disable this draw call by setting to zero
            instanceDrawDataIn[k].z, // offset in the index buffer
            instanceDrawDataIn[k].x, // offset in the vertex buffer. Note that you can use this to "reindex" submeshses - all indicies in this draw will be decremented by this amount
            k// offset in the instance buffer. If you are drawing more than 1 instance per call see gpudrivenrendering for how to handle
            );
        }
        else {
            drawIndexedIndirect(
            // Target location params:
            indirectBuffer, // target buffer
            k, // index in buffer
            // Draw call params:
            instanceDrawDataIn[k].w, // number of indices for this draw call
            0u, // number of instances for this draw call. You can disable this draw call by setting to zero
            instanceDrawDataIn[k].z, // offset in the index buffer
            instanceDrawDataIn[k].x, // offset in the vertex buffer. Note that you can use this to "reindex" submeshses - all indicies in this draw will be decremented by this amount
            k// offset in the instance buffer. If you are drawing more than 1 instance per call see gpudrivenrendering for how to handle
            );
        }
    }

    if (tId == 0)
    {
        // If BGFX_CAPS_DRAW_INDIRECT_COUNT is supported, you can limit the
        // number of draw calls dynamically without a CPU round trip
        indirectCountBuffer[0] = maxToDraw;
    }
}